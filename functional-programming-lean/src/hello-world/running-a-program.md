# プログラムの実行（Running a Program）

Leanプログラムを実行する最も簡単な方法は、Lean実行可能ファイルに`--run`オプションを使用することです。
`Hello.lean`という名前のファイルを作成し、次の内容を入力します：

```lean
{{#include ../../../examples/simple-hello/Hello.lean}}
```

次に、コマンドラインから以下を実行します：

```
{{#command {simple-hello} {hello} {lean --run Hello.lean} }}
```

このプログラムは`{{#command_out {hello} {lean --run Hello.lean} }}`を表示して終了します。


## 挨拶の構造（Anatomy of a Greeting）

Leanを`--run`オプションで呼び出すと、プログラムの`main`定義が呼び出されます。
コマンドライン引数を取らないプログラムの場合、`main`の型は`IO Unit`であるべきです。
これは、`main`が関数ではないことを意味します。なぜなら、その型には矢印（`→`）が含まれていないからです。
副作用を持つ関数ではなく、`main`は実行されるべき効果の説明です。

[前の章](../getting-to-know/polymorphism.md)で議論されたように、`Unit`は最も単純な帰納型です。
`unit`という引数を取らない単一のコンストラクタを持っています。
C系の言語には、何の値も返さない`void`関数の概念があります。
Leanでは、すべての関数が引数を取り、値を返し、興味深い引数や返り値がないことは、代わりに`Unit`型を使用して示すことができます。
`Bool`が情報の1ビットを表すのであれば、`Unit`は情報のゼロビットを表します。

`IO α`は、実行されると例外をスローするか、型`α`の値を返すプログラムの型です。
実行中、このプログラムには副作用が発生する可能性があります。
これらのプログラムは`IO` _アクション_ と呼ばれます。
Leanは、数学的な式の値の代入と副効果のない部分式の削減に厳密に従う _評価_ と、世界と対話するために外部システムを使用する _実行_ の区別をしています。
`IO.println`は文字列から`IO`アクションへの関数で、実行すると指定された文字列を標準出力に書き込みます。
このアクションは文字列の発行の過程で環境から興味深い情報を読み取らないため、`IO.println`の型は`String → IO Unit`です。
何か興味深いものを返す場合、それは`IO`アクションの型が`Unit`以外であることで示されるでしょう。



## 関数型プログラミングと副作用（Functional Programming vs Effects）

Leanの計算モデルは、変数が時間の経過とともに変わらない正確な値を持つ数学的式の評価に基づいています。
式を評価した結果は変わらず、同じ式を再び評価しても常に同じ結果が得られます。

一方、有用なプログラムは世界と対話する必要があります。
入力や出力を行わないプログラムは、ユーザーからデータを要求したり、ディスクにファイルを作成したり、ネットワーク接続を開いたりすることはできません。
Leanは自己記述型であり、Leanコンパイラはファイルを読み込んだり、ファイルを作成したり、テキストエディタと対話したりします。
同じ式が常に同じ結果を返す言語が、これらのファイルの内容が時間の経過とともに変化する可能性があるファイルをディスクから読み込むプログラムをサポートする方法はどうなのでしょうか？

この明らかな矛盾は、副作用について少し異なる考え方をすることで解決できます。
コーヒーやサンドイッチを販売するカフェを想像してみてください。
このカフェには2人の従業員がいます：注文を満たす料理人と、顧客と対話し注文伝票を出すカウンターの従業員です。
料理人は外部の世界と接触することを本当に好まず、静かな環境が必要で、カフェが知られている料理と飲み物を一貫して提供するのが得意です。
しかし、これを行うためには料理人は平和と静けさが必要で、会話で邪魔されることはできません。
カウンターの従業員は親しみやすいが、キッチンの仕事は完全にできません。
顧客はカウンターの従業員と対話し、実際の料理のすべてを料理人に委任します。
料理人が顧客に質問がある場合、アレルギーなどを明確にする場合、カウンターの従業員に小さなメモを送り、顧客とやり取りし、結果をメモで料理人に返します。

このアナロジーでは、料理人はLean言語を表しています。
注文が与えられると、料理人は忠実で一貫性のあるサービスを提供します。
カウンターの従業員は、世界と対話し、支払いを受け取り、食事を提供し、顧客との対話を行う周囲のランタイムシステムです。
2人の従業員は協力して、レストランのすべての機能を提供しますが、彼らの責任は分かれており、それぞれが得意なタスクを実行します。
顧客を遠ざけることが料理人に本当に優れたコーヒーとサンドイッチを作ることに集中させるのと同様に、Leanの副作用のなさはプログラムが形式的な数学的証明の一部として使用できるようにします。
また、隠れた状態の変化がコンポーネント間の微妙な結合を作成することがないため、プログラムの部分を互いに分離して理解するのを助けます。
料理人のメモは、Lean式を評価して生成される`IO`アクションを表し、カウンターの従業員の返答は効果から渡される値です。

この副作用のモデルは、Lean言語全体、そのコンパイラ、およびランタイムシステム（RTS）の総合的な動作方法とかなり類似しています。
ランタイムシステム内のプリミティブは、Cで書かれ、すべての基本的な効果を実装しています。
プログラムを実行する際、RTSは`main`アクションを呼び出し、新しい`IO`アクションを実行するためにRTSに返します。
RTSはこれらのアクションを実行し、ユーザーのLeanコードに計算を実行するよう委任します。
Leanの内部の視点からは、プログラムには副作用がなく、`IO`アクションは実行されるべきタスクの説明にすぎません。
プログラムのユーザーの外部の視点からは、プログラムのコアロジックへのインターフェースを作成する副作用のレイヤーが存在します。


Leanにおける副作用について考えるもう一つの有用な方法は、`IO`アクションを、世界全体を引数として受け取り、新しい世界と値を返す関数と考えることです。
この場合、標準入力からテキストを読み取ることは純粋な関数です。なぜなら、異なる世界が各引数として提供されるからです。
標準出力にテキストを書き込むことも純粋な関数です。なぜなら、関数が返す世界は開始時のものと異なるからです。
プログラムは世界を再利用しないように注意し、新しい世界を返さないようにする必要があります。それは結局、時間旅行または世界の終了につながることになるからです。
慎重な抽象境界によって、このプログラミングスタイルは安全になります。
すべてのプリミティブな`IO`アクションが一つの世界を受け入れ、新しい世界を返し、この不変条件を保つツールとしか組み合わせることができない場合、問題は発生しないのです。

このモデルは実装できません。
結局のところ、宇宙全体をLeanの値に変えてメモリに配置することはできません。
ただし、このモデルのバリエーションを、世界を表す抽象トークンを使用して実装することは可能です。
プログラムが開始されると、世界のトークンが提供されます。
その後、このトークンはIOプリミティブに渡され、返されたトークンも同様に次のステップに渡されます。
プログラムの終了時には、トークンはオペレーティングシステムに返されます。

この副作用のモデルは、Lean内部でRTSによって実行されるタスクの説明としての`IO`アクションがどのように表現されているかを良く説明しています。
実際の世界を変える関数は抽象バリアの背後に隠れています。
しかし、実際のプログラムは通常、1つだけでなく一連の効果から成り立っています。
プログラムが複数の効果を使用できるようにするために、`do`表記と呼ばれるLeanのサブ言語があり、これらの基本的な`IO`アクションを安全に組み合わせて大規模で有用なプログラムに構築できるようになります。


## `IO`アクションの結合（Combining `IO` Actions）

ほとんどの有用なプログラムは、出力の生成に加えて入力も受け入れます。さらに、それらは入力に基づいて決定を下すことがあり、入力データを計算の一部として使用することがあります。次のプログラム、`HelloName.lean`は、ユーザーに名前を尋ね、それから挨拶をします。

```lean
{{#include ../../../examples/hello-name/HelloName.lean:all}}
```

このプログラムでは、`main`アクションは`do`ブロックで構成されています。このブロックには、_ステートメント_ のシーケンスが含まれます。ステートメントは、ローカル変数（`let`を使用して導入）と実行されるアクションの両方である可能性があります。SQLがデータベースと対話するための特別な目的の言語と考えることができるように、`do`構文は、Lean内で命令型プログラムをモデル化するために専用のサブ言語と考えることができます。`do`ブロックで構築された`IO`アクションは、ステートメントを順番に実行することで実行されます。

このプログラムは、以前のプログラムと同じ方法で実行できます。

```
{{#command {hello-name} {hello-name} {./run} {lean --run HelloName.lean}}}
```

ユーザーが`David`と応答する場合、プログラムとの対話セッションが次のように表示されます。

```
{{#command_out {hello-name} {./run} }}
```

型のシグネチャ行は、`Hello.lean`のものと同じです。

```lean
{{#include ../../../examples/hello-name/HelloName.lean:sig}}
```

唯一の違いは、キーワード`do`で終わることで、コマンドのシーケンスを開始します。`do`のキーワードに続くインデントされた各行は、同じコマンドのシーケンスの一部です。

最初の2行は、次のように記載されています：

```lean
{{#include ../../../examples/hello-name/HelloName.lean:setup}}
```

これらの行は、ライブラリアクション`IO.getStdin`および`IO.getStdout`を実行して`stdin`と`stdout`のハンドルを取得します。`do`ブロックでは、通常の式とは異なり、`let`にはやや異なる意味があります。通常、`let`で導入されたローカル定義は、すぐにそのローカル定義に続く式でしか使用できません。`do`ブロックでは、`let`によって導入されたローカルバインディングは、次の式だけでなく、`do`ブロックの残りのすべてのステートメントで使用できます。さらに、通常、`let`は名前を定義の右側に`:=`を使用して接続しますが、`do`の一部の`let`バインディングでは、代わりに左矢印(`←`または`<-`)を使用します。矢印を使用すると、式の右側の値が実行されるべき`IO`アクションで、そのアクションの結果がローカル変数に保存されます。言い換えれば、矢印の右側の式が型`IO α`を持つ場合、その変数は`do`ブロックの残りの部分で型`α`を持ちます。`IO.getStdin`および`IO.getStdout`は`stdin`と`stdout`をプログラム内でローカルにオーバーライドできるようにするために`IO`アクションです。これは便利なことです。Cのようにグローバル変数であった場合、これらをオーバーライドする有意義な方法はありませんが、`IO`アクションは実行されるたびに異なる値を返すことができます。

`do`ブロックの次の部分は、ユーザーに名前を尋ねる責任があります：

```lean
{{#include ../../../examples/hello-name/HelloName.lean:question}}
```

最初の行は質問を`stdout`に書き込み、2番目の行は`stdin`から入力をリクエストし、3番目の行は入力行から末尾の改行（および他の末尾の空白）を削除します。`name`の定義では、`String.dropRightWhile`は`IO`アクションではなく、通常の文字列関数であるため、`:=`ではなく`←`を使用しています。

最後の行は、プログラムの最後です：

```
{{#include ../../../examples/hello-name/HelloName.lean:answer}}
```

この行は、提供された名前を挨拶の文字列に挿入するために[文字列補間](../getting-to-know/conveniences.md#string-interpolation)を使用し、その結果を`stdout`に書き込みます。
