# 追加の話題（Additional Conveniences）

## ネストされたアクション（Nested Actions）

`feline`の多くの関数では、`IO`アクションの結果に名前が付けられ、それがすぐにかつ一度だけ使用される繰り返しのパターンが見られます。例えば、`dump`の場合：

```lean
{{#include ../../../examples/feline/2/Main.lean:dump}}
```

このパターンは`stdout`の場合にも発生します：

```lean
{{#include ../../../examples/feline/2/Main.lean:stdoutBind}}
```

同様に、`fileStream`には次のコードスニペットが含まれています：

```lean
{{#include ../../../examples/feline/2/Main.lean:fileExistsBind}}
```

Leanが`do`ブロックをコンパイルする際、括弧の下にある左矢印からなる式は、最も近い包含の`do`に持ち上げられ、その結果は一意の名前にバインドされます。
この一意の名前は式の元を置き換えます。
つまり、`dump`は以下のようにも書くことができます：

```lean
{{#example_decl Examples/Cat.lean dump}}
```

このバージョンの`dump`は、一度だけ使用される名前を導入しないため、プログラムを大幅に簡略化できます。
Leanがネストされた式コンテキストから持ち上げる`IO`アクションは _ネストされたアクション_ と呼ばれます。

同じテクニックを使用して`fileStream`を簡素化できます：

```lean
{{#example_decl Examples/Cat.lean fileStream}}
```

この場合、`handle`のローカル名もネストされたアクションを使用して削除できましたが、その結果の式は長く複雑になりました。
ネストされたアクションを使用することが一般的に良いスタイルであるにもかかわらず、中間結果に名前を付けることが時々役立つこともあります。

ただし、ネストされたアクションは、周囲の`do`ブロック内で発生する`IO`アクションの短縮表記に過ぎないことを覚えておくことが重要です。
これらを実行する際に関与する副作用は、依然として同じ順序で発生し、副作用の実行は式の評価と交互に行われるわけではありません。
これが混乱の原因となる可能性がある例を考えてみましょう。以下のヘルパー定義を考えてみてください。これらの定義は実行されたことを世界に宣言した後にデータを返します：

```lean
{{#example_decl Examples/Cat.lean getNumA}}

{{#example_decl Examples/Cat.lean getNumB}}
```

これらの定義は、ユーザー入力を検証したり、データベースを読み取ったり、ファイルを開いたりするかもしれない、より複雑な`IO`コードの代わりに立つものです。

数Aが5の場合に0を出力し、それ以外の場合に数Bを出力するプログラムは、次のように書くことができます：

```lean
{{#example_decl Examples/Cat.lean testEffects}}
```

しかし、このプログラムはおそらく意図したよりも多くの副作用（ユーザー入力のプロンプトやデータベースの読み取りなど）を持っている可能性があります。
`getNumA`の定義は、常に`5`を返すことを明示しており、したがってプログラムは数Bを読み取る必要はありません。
しかし、プログラムを実行すると、次の出力が得られます：

```output info
{{#example_out Examples/Cat.lean runTest}}
```

`getNumB`が実行されたのは、`test`が次の定義と同等であるためです：

```lean
{{#example_decl Examples/Cat.lean testEffectsExpanded}}
```

これは、ネストされたアクションが最も近い包含する`do`ブロックに持ち上げられるというルールに起因しています。
`if`のブランチは`do`ブロック内の文ではないため、暗黙のうちに`do`ブロックでラップされなかったのです。宣言されているのは`a`を定義する`let`です。
実際、このようにラップすることはできなかったのです。なぜなら、条件式の型は`Nat`であり、`IO Nat`ではないからです。


## `do`の柔軟なレイアウト（Flexible Layouts for `do`）

Leanでは、`do` 式は空白に敏感です。
`do`内の各`IO`アクションまたはローカルバインディングは、独自の行で開始されることが期待され、それらはすべて同じインデントを持つべきです。
ほとんどの場合、`do`はこの方法で書かれるべきです。
しかしながら、一部のまれなコンテキストでは、空白とインデントを手動で制御する必要があるか、または1行に複数の小さなアクションを配置するのが便利な場合があります。
これらの場合、改行をセミコロンに置き換え、インデントを中括弧に置き換えることができます。

たとえば、以下のプログラムはすべて等価です：

```lean
{{#example_decl Examples/Cat.lean helloOne}}

{{#example_decl Examples/Cat.lean helloTwo}}

{{#example_decl Examples/Cat.lean helloThree}}
```

イディオマティックなLeanコードでは、`do`に中括弧をほとんど使用しません。

## `#eval`を使用した`IO`アクションの実行（Running `IO` Actions With `#eval`）

Leanの`#eval`コマンドは、`IO`アクションを実行するために使用できます。評価だけでなく、実行も行います。
通常、Leanファイルに`#eval`コマンドを追加すると、Leanは提供された式を評価し、その結果の値を文字列に変換し、その文字列をツールチップと情報ウィンドウで提供します。
`IO`アクションは文字列に変換できないため、代わりに`#eval`はそれらを実行し、副作用を実行します。
実行の結果が`Unit`値`()`である場合、結果の文字列は表示されませんが、文字列に変換できる型である場合、Leanは結果の値を表示します。

これは、`countdown`と`runActions`の以前の定義が与えられた場合、次のように表示されます：

```lean
{{#example_in Examples/HelloWorld.lean evalDoesIO}}
```

出力は次の通りです：

```output info
{{#example_out Examples/HelloWorld.lean evalDoesIO}}
```

これは、`IO`アクションを実行した結果の出力であり、アクション自体の不透明な表現ではありません。
つまり、`IO`アクションに関して、`#eval`は提供された式を「評価」し、結果のアクション値を「実行」します。

`#eval`を使用して迅速に`IO`アクションをテストすることは、プログラム全体をコンパイルおよび実行するよりもはるかに便利な場合があります。
ただし、いくつかの制限があります。
たとえば、標準入力から読み取るだけでは空の入力が返されます。
さらに、Leanがユーザーに提供する診断情報を更新する必要があるときに、`IO`アクションは再実行され、これは予測不可能なタイミングで発生する可能性があります。
ファイルの読み取りと書き込みを行うアクションは、適切でないタイミングで実行されるかもしれません。
