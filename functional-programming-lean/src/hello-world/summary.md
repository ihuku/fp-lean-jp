# サマリ（Summary）

## 評価と実行（Evaluation vs Execution）

副作用は、数学的式の評価を超えるプログラムの実行の側面であり、ファイルの読み取り、例外のスロー、産業機械のトリガーなどが該当します。
ほとんどの言語では副作用が評価中に発生することが許可されていますが、Leanは許可しません。
代わりに、Leanには副作用を使用するプログラムの_記述_を表す「IO」という型があります。
これらの記述は、その後、言語の実行時システムによって実行され、Leanの式評価器を呼び出して特定の計算を実行します。
型`IO α`の値は _`IO`アクション_ と呼ばれます。
最も単純なのは「pure」で、引数を返し、実際の副作用はありません。

`IO`アクションは、副作用が発生した新しい状態を返す関数としても理解できます。
裏側では、`IO`ライブラリは世界が二重化、作成、または破壊されないように保証します。
この副作用のモデルは実際には実装できないものです。なぜなら、宇宙全体はメモリに収まるには大きすぎるためですが、実際の世界はプログラム内で渡されるトークンで表現できます。

`IO`アクション`main`はプログラムが開始されるときに実行されます。
`main`は次の3つの型のいずれかを持つことができます：
 * `main : IO Unit`は、コマンドライン引数を読み取ることができず、常に終了コード`0`を返す単純なプログラムに使用されます。
 * `main : IO UInt32`は引数を持たないプログラムに使用され、成功または失敗を示す可能性があります。
 * `main : List String → IO UInt32`はコマンドライン引数を受け取り、成功または失敗を示すプログラムに使用されます。

## `do` 表記（`do` Notation）

Leanの標準ライブラリは、ファイルから読み取りや書き込み、標準入力および標準出力との対話など、効果を表す基本的な`IO`アクションをいくつか提供しています。
これらの基本`IO`アクションは、効果を持つプログラムの記述を書くための組み込みのドメイン固有言語である`do`表記を使用して、大きな`IO`アクションに結合されます。
`do`式には、次のものが含まれています：
 * `IO`アクションを表す式
 * `let`と`:=`を使用した通常のローカル定義、定義された名前が提供された式の値を参照する場合
 * `let`と`←`を使用したローカル定義、定義された名前が提供された式の値を実行した結果を参照する場合

`do`で書かれた`IO`アクションは、1つのステートメントごとに実行されます。

さらに、`do`の直下にある`if`および`match`式は、それぞれのブランチに独自の`do`を持っていると暗黙的に考えられます。
`do`式内部で、_ネストされたアクション_は、括弧の直下に左矢印を持つ式です。
Leanコンパイラはこれらを最も近い包括的な`do`に暗黙的に持ち上げ、それに一意の名前を付けます。
この一意の名前は、ネストされたアクションの元の場所を置き換えます。


## プログラムのコンパイルと実行（Compiling and Running Programs）

`main`の定義を持つ単一のファイルから成るLeanプログラムは、`lean --run FILE`を使用して実行できます。
これは単純なプログラムを始めるための素敵な方法であるかもしれませんが、ほとんどのプログラムは実行する前にコンパイルする必要がある多くのファイルからなるプロジェクトに進化するでしょう。

Leanプロジェクトは_パッケージ_に整理されており、これらは依存関係とビルド設定に関する情報と一緒にライブラリと実行ファイルのコレクションです。
パッケージはLeanのビルドツールであるLakeを使用して記述されます。
新しいディレクトリにLakeパッケージを作成するには`lake new`を使用し、カレントディレクトリに作成するには`lake init`を使用します。
Lakeパッケージの設定もまたドメイン固有の言語です。
プロジェクトをビルドするには`lake build`を使用します。

## 部分性（Partiality）

数学的な式の評価モデルに従う結果、すべての式は値を持たなければなりません。
これにより、データ型のすべてのコンストラクタをカバーしない不完全なパターンマッチや、無限ループに陥る可能性のあるプログラムの両方が排除されます。
Leanは、すべての`match`式がすべてのケースをカバーし、すべての再帰関数が構造的に再帰的であるか、明示的な終了の証明を持っていることを確認します。

ただし、一部の実際のプログラムは、潜在的に無限のデータを扱うために無限ループの可能性が必要である場合があります。例えば、POSIXストリームなどです。
Leanは脱出口を提供します。その定義が`partial`とマークされた関数は終了が必要ではありません。
ただし、これにはコストがかかります。
型がLean言語の一等の要素であるため、関数は型を返すことができます。
部分関数は型チェック中に評価されないため、関数内の無限ループは型チェッカーが無限ループに入る可能性があるためです。
さらに、数学的な証拠は部分関数の定義を調べることができないため、これらを使用するプログラムは形式的な証明には適していないことがあります。
