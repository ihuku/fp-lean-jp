# 実例：`cat`（Worked Example: `cat`）

標準のUnixユーティリティである `cat` は、いくつかのコマンドラインオプションと、ゼロ個以上の入力ファイルを受け取ります。
ファイルが提供されないか、提供されたファイルの1つがダッシュ（`-`）である場合、対応する入力としてファイルを読み取る代わりに標準入力を受け取ります。
入力の内容は、一つの入力の後にもう一つの入力が続く形で標準出力に書き込まれます。
指定された入力ファイルが存在しない場合、これは標準エラーに注意されますが、`cat` は残りの入力を連結し続けます。
入力ファイルのいずれかが存在しない場合、ゼロでない終了コードが返されます。

このセクションでは、`cat` の簡略版である `feline` を説明します。
一般的に使用される `cat` のように、`feline` には行に番号をつけたり、非表示文字を示したり、ヘルプテキストを表示するためのコマンドラインオプションはありません。
さらに、端末デバイスに関連付けられた標準入力から複数回読み取ることはできません。

このセクションから最大の利益を得るためには、自分で進行しながら進めてください。
コードの例をコピーアンドペーストしても問題ありませんが、手動でコードを入力したほうがさらに良いでしょう。
これにより、コードの入力プロセス、エラーからの回復、コンパイラからのフィードバックの解釈が容易になります。

## Getting started

`feline` の実装の最初のステップは、パッケージを作成し、コードの組織方法を決定することです。
この場合、プログラムが非常にシンプルであるため、すべてのコードは `Main.lean` に配置されます。
最初のステップは、`lake new feline` を実行することです。
Lakefileを編集してライブラリを削除し、生成されたライブラリコードとその参照を `Main.lean` から削除します。
これが完了したら、`lakefile.lean` は次のようになるはずです：

```lean
{{#include ../../../examples/feline/1/lakefile.lean}}
```

そして `Main.lean` は次のような内容になるはずです：
```lean
{{#include ../../../examples/feline/1/Main.lean}}
```

または、`lake new feline exe` を実行することで、ライブラリセクションを含まないテンプレートを使用するように `lake` に指示でき、ファイルを編集する必要がなくなります。

コードをビルドできることを確認するために、次のコマンドを実行してください： `{{#command {feline/1} {feline/1} {lake build} }}`


## ストリームの連結（Concatenating Streams）

プログラムの基本的な骨組みができたので、実際にコードを入力する時がきました。
`cat` の適切な実装は `/dev/random` などの無限のIOストリームで使用できます。つまり、出力する前に入力をメモリに読み込むことはできません。
さらに、1文字ずつ処理するべきではありません。なぜなら、これは非常に遅いパフォーマンスをもたらすからです。
代わりに、データを連続したブロックとして一度に読み取り、データを標準出力にブロックごとに送る方が良いです。

最初のステップは、どれだけの大きさのブロックを読むかを決定することです。
単純さのために、この実装では慎重な20キロバイトのブロックを使用しています。
`USize` は C の `size_t` に似ており、すべての有効な配列サイズを表現できる十分に大きな符号なし整数型です。

```lean
{{#include ../../../examples/feline/2/Main.lean:bufsize}}
```

### ストリーム（Streams）

`feline` の主な作業は `dump` によって行われ、入力を1つのブロックずつ読み込み、その結果を標準出力にダンプし、入力の終わりに達するまで続けます：

```lean
{{#include ../../../examples/feline/2/Main.lean:dump}}
```

`dump` 関数は `partial` で宣言されています。なぜなら、引数よりも直ちに小さくない入力に対して再帰的に自分自身を呼び出すからです。
関数が `partial` と宣言されると、Leanはそれが終了することの証明を必要としません。
一方、部分関数は正当性の証明には適しておらず、Leanの論理に無限ループを許可することは非常に非合理です。
ただし、`dump` が終了することを証明する方法はないため、（`/dev/random`などの）無限の入力がある場合、実際には終了しないことになります。
このような場合、関数を `partial` と宣言する以外の方法はありません。

型 `IO.FS.Stream` はPOSIXストリームを表します。
内部的には、それは各POSIXストリーム操作に対応する1つのフィールドを持つ構造体として表現されます。
各操作は、対応する操作を提供するIOアクションとして表現されます：

```lean
{{#example_decl Examples/Cat.lean Stream}}
```

Leanコンパイラには、標準入力、標準出力、標準エラーを表すストリームを取得するための `IO` アクション（`dump` で呼び出される `IO.getStdout` など）が含まれています。
これらは通常の定義ではなく `IO` アクションです。なぜなら Lean はこれらの標準のPOSIXストリームをプロセス内で置き換えることを許可しており、これによりプログラムの出力を文字列にキャプチャするなどの作業が簡単になります。

`dump` 内の制御フローは基本的に `while` ループです。
`dump` が呼び出されると、ストリームがファイルの終わりに達している場合、`pure ()` は `Unit` のコンストラクタを返すことで関数を終了させます。
ストリームがファイルの終わりに達していない場合、1つのブロックが読み取られ、その内容が `stdout` に書き込まれた後、`dump` は直接自分自身を呼び出します。
再帰呼び出しは、`stream.read` が空のバイト配列を返すまで続き、これはファイルの終わりに達したことを示します。

`if` 式が `do` のステートメントとして現れる場合、例えば `dump` のように、`if` の各ブランチは暗黙的に `do` が提供されます。
つまり、`else` の後に続く手順は、`do` の開始があるかのように実行される `IO` アクションのシーケンスとして扱われます。
`if` のブランチ内で `let` で導入された名前は、それぞれのブランチ内でのみ見え、`if` の外部のスコープにはありません。

`dump` を呼び出す際にスタック領域が枯渇する心配はありません。なぜなら、再帰呼び出しは関数内の非常に最後のステップとして行われ、その結果は操作や計算に利用されるのではなく、直接返されるからです。この種の再帰は「テール再帰」と呼ばれ、[この本の後の部分](../programs-proofs/tail-recursion.md)で詳しく説明されています。
コンパイルされたコードは状態を保持する必要がないため、Leanコンパイラは再帰呼び出しをジャンプにコンパイルできます。

もし `feline` が標準入力を標準出力にリダイレクトするだけであれば、`dump` は十分です。
しかし、コマンドライン引数として提供されたファイルを開いてその内容を出力できる必要もあります。
引数が存在するファイルの名前の場合、`fileStream` はそのファイルの内容を読むストリームを返します。
引数がファイルでない場合、`fileStream` はエラーを発生させて `none` を返します。

```lean
{{#include ../../../examples/feline/2/Main.lean:fileStream}}
```

ファイルをストリームとして開くには2つのステップが必要です。
まず、ファイルハンドルが読み込みモードでファイルを開くことによってファイルハンドルが作成されます。
Leanファイルハンドルは、基になるファイルディスクリプタを追跡します。
ファイルハンドル値への参照がない場合、ファイルディスクリプタを閉じるファイナライザが実行されます。
次に、ファイルハンドルに `IO.FS.Stream.ofHandle` を使用して、`Stream` 構造の各フィールドに対応するファイルハンドルで動作する `IO` アクションを提供します。


### 入力の処理（Handling Input）

`feline` のメインループは、別のテール再帰関数である `process` です。
入力が読み取れない場合に非ゼロの終了コードを返すために、`process` はプログラム全体の現在の終了コードを表す引数 `exitCode` を取ります。
さらに、処理されるべき入力ファイルのリストを受け取ります。

```lean
{{#include ../../../examples/feline/2/Main.lean:process}}
```

`if` と同様に、`do` のステートメントとして使用される `match` の各ブランチは、それぞれ独自の `do` が暗黙的に提供されます。

3つの可能性があります。
1つは、処理するファイルがもう残っていない場合で、その場合、`process` はエラーコードを変更せずに返します。
もう一つは、指定されたファイル名が `"-"` の場合、`process` は標準入力の内容をダンプし、その後残りのファイル名を処理します。
最後の可能性は、実際のファイル名が指定された場合です。
この場合、ファイルをPOSIXストリームとして開くために `fileStream` が使用されます。
その引数は `FilePath` で囲まれています。なぜなら、`FilePath` は文字列を含む単一のフィールド構造体であるからです。
ファイルを開けない場合はスキップされ、`process` の再帰呼び出しは終了コードを `1` に設定します。
開けた場合、ファイルはダンプされ、`process` の再帰呼び出しは終了コードを変更しません。

`process` には `partial` のマークが必要ありません。なぜなら、それは構造的に再帰的であるからです。
各再帰呼び出しは入力リストの残り部分で提供され、すべてのLeanリストは有限です。
したがって、`process` は非終了を導入しません。


### Main

最後のステップは `main` アクションを記述することです。
以前の例とは異なり、`feline` の `main` は関数です。
Leanでは、`main` には3つのタイプがあります：
 * `main : IO Unit` は、コマンドライン引数を読み込むことができないプログラムに対応し、常に終了コード `0` で成功を示します。
 * `main : IO UInt32` は、引数を取らずに終了コードを返すプログラムに対応し、Cの `int main(void)` に対応します。
 * `main : List String → IO UInt32` は、引数を取り、成功または失敗を示すプログラムに対応し、Cの `int main(int argc, char **argv)` に対応します。

引数が提供されない場合、`feline` は単一の `"-"` 引数で呼び出されたかのように標準入力から読み込むべきです。
それ以外の場合、引数は順番に処理されるべきです。

```lean
{{#include ../../../examples/feline/2/Main.lean:main}}
```


## ニャー！（Meow!）

## ミャオ！

`feline` が正しく動作するかどうかを確認するために、最初のステップは `{{#command {feline/2} {feline/2} {lake build} }}` を使ってビルドすることです。
まず、引数なしで呼び出された場合、標準入力から受け取った内容を出力するべきです。
次のコマンドを確認してください：
```
{{#command {feline/2} {feline/2} {echo "It works!" | ./build/bin/feline} }}
```
が `{{#command_out {feline/2} {echo "It works!" | ./build/bin/feline} }}` を出力するか確認してください。

次に、ファイルを引数として呼び出された場合、それらを印刷するべきです。
ファイル `test1.txt` に次の内容が含まれている場合：
```
{{#include ../../../examples/feline/2/test1.txt}}
```
そして `test2.txt` に次の内容が含まれている場合：
```
{{#include ../../../examples/feline/2/test2.txt}}
```
次のコマンド：
```
{{#command {feline/2} {feline/2} {./build/bin/feline test1.txt test2.txt} }}
```
は次の内容を出力するべきです：
```
{{#command_out {feline/2} {./build/bin/feline test1.txt test2.txt} {feline/2/expected/test12.txt} }}
```

最後に、`-` 引数は適切に処理されるべきです。
```
{{#command {feline/2} {feline/2} {echo "and purr" | ./build/bin/feline test1.txt - test2.txt} }}
```
は次の内容を出力すべきです：
```
{{#command_out {feline/2} {echo "and purr" | ./build/bin/feline test1.txt - test2.txt} {feline/2/expected/test1purr2.txt}}}
```

## 演習（Exercise）

`feline` を使用情報のサポートと拡張してください。
拡張バージョンは、コマンドライン引数 `--help` を受け入れ、利用可能なコマンドラインオプションに関するドキュメンテーションを標準出力に書き込むようにする必要があります。
