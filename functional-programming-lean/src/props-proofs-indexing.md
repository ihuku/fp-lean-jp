# 間奏: 命題、証明、およびインデックス（Interlude: Propositions, Proofs, and Indexing）

Leanは多くの言語と同様に、配列やリストへのインデックスに角かっこを使用します。
例えば、`woodlandCritters`が以下のように定義されている場合：

```lean
{{#example_decl Examples/Props.lean woodlandCritters}}
```

個々のコンポーネントは以下のように抽出できます：

```lean
{{#example_decl Examples/Props.lean animals}}
```

しかし、4番目の要素を抽出しようとすると、実行時のエラーではなく、コンパイル時のエラーが発生します：

```lean
{{#example_in Examples/Props.lean outOfBounds}}
```
```output error
{{#example_out Examples/Props.lean outOfBounds}}
```

このエラーメッセージは、Leanが自動的に `3 < List.length woodlandCritters` を数学的に証明しようと試みたことを示しており、これは参照が安全であることを意味しますが、それができなかったことを示しています。
範囲外のエラーは一般的なバグの一種であり、Leanはプログラム言語と定理証明器としての二重の性質を活かして、できる限りこれを排除しようとします。

これがどのように機能するかを理解するには、「命題」、「証明」、および「戦術（タクティク）」という、3つの重要な概念を理解する必要があります。

## 命題と証明（Propositions and Proofs）

命題（proposition）は真または偽であると言える文です。
以下はすべて命題です：

 * 1 + 1 = 2
 * 足し算は可換である
 * 無限に多くの素数が存在する
 * 1 + 1 = 15
 * パリはフランスの首都である
 * ブエノスアイレスは韓国の首都である
 * すべての鳥は飛べる

一方、無意味な文は命題ではありません。
以下はすべて命題ではありません：

 * 1 + green = ice cream
 * すべての首都は素数である
 * 少なくとも1つのゴーグはフリープである

命題は2つの種類に分かれます：数学的に完全に定義された概念に依存するものと、世界に関する事実に関するものです。
Leanのような定理証明器は前者のカテゴリに関心を寄せており、ペンギンの飛行能力や都市の法的地位については何も言うことがありません。

_証明（proof）_ は命題が真であるという説得力のある議論です。
数学的な命題の場合、これらの議論は関連する概念の定義と論理的論証のルールを使用します。
ほとんどの証明は他の人が理解できるように書かれ、多くの煩わしい詳細は省略されます。
Leanのようなコンピュータ支援定理証明器は、数学者が多くの詳細を省略しながら証明を書くことを可能にするように設計されており、欠落している明示的なステップをソフトウェアが補完する責任があります。
これにより、見落としやミスの発生率が低下します。

Leanでは、プログラムの型がそれと対話できる方法を記述します。
たとえば、型が `Nat → List String` のプログラムは、`Nat` 引数を受け取り、文字列のリストを生成する関数です。
言い換えれば、各型はその型のプログラムとして何を考慮するかを指定します。

Leanでは、実際の命題は実際には型です。
それらは文が真であるという証拠として何が考慮されるかを指定します。
命題はこの証拠を提供することによって証明されます。
一方、命題が偽である場合、この証拠を構築することは不可能です。

例えば、命題 "1 + 1 = 2" はLeanで直接書くことができます。
この命題の証拠は、_反射性（reflexivity）_ の略であるコンストラクタ `rfl` です：

```lean
{{#example_decl Examples/Props.lean onePlusOneIsTwo}}
```

一方、`rfl` は偽の命題 "1 + 1 = 15" を証明しません：

```lean
{{#example_in Examples/Props.lean onePlusOneIsFifteen}}
```
```output error
{{#example_out Examples/Props.lean onePlusOneIsFifteen}}
```

このエラーメッセージは、`rfl` が等式文の両側がすでに同じ数値であるときに2つの式が等しいことを証明できることを示しており、`1 + 1` が直接 `2` に評価されるため、それらは同じと考えられるため、`onePlusOneIsTwo` が受け入れられるとされています。
`Type` がデータ構造と関数を表す型（`Nat`、`String`、`List (Nat × String × (Int → Float))`など）を説明するのと同様に、`Prop` は命題を説明します。

命題が証明されたとき、それを _定理（theorem）_ と呼びます。
Leanでは、定義の代わりに `def` の代わりに `theorem` キーワードを使用するのが通例です。
これにより、読者はどの宣言が数学的な証明として読むことを意図しているか、または定義であるかを見分けるのに役立ちます。
一般的に、証明において重要なのは命題が真である証拠があることであり、提供された具体的な証拠はそれほど重要ではありませんが、一方、定義においては、選択される特定の値が非常に重要です。結局、常に `0` を返す足し算の定義は明らかに誤っています。

前の例は以下のように書き直すことができます：

```lean
{{#example_decl Examples/Props.lean onePlusOneIsTwoProp}}
```

## Tactics

通常、証明は証拠を直接提供するのではなく、_戦術（tactics）_ を使用して書かれます。
戦術は命題の証拠を構築する小さなプログラムです。
これらのプログラムは、証明されるべき文（_ゴール（goal）_ と呼ばれる）とそれを証明するために使用できる仮定を追跡する _証明状態（proof state）_ で実行されます。
ゴールに対して戦術を実行すると、新しい証明状態が生成され、新しいゴールが含まれます。
全てのゴールが証明されると、証明が完了します。

戦術を使用して証明を書く場合、定義を `by` で始めます。
`by` を書くことで、Leanは次のインデントされたブロックの終わりまで戦術モードに入ります。
戦術モードでは、Leanは現在の証明状態に関する進行中のフィードバックを提供します。
戦術を使用して書かれた場合、`onePlusOneIsTwo` はまだ非常に短くなります：

```leantac
{{#example_decl Examples/Props.lean onePlusOneIsTwoTactics}}
```

`simp` 戦術（"simplify"、「簡略化」の略）は、Leanの証明の中核です。
これはゴールをできるだけ簡単な形に書き換え、証明の一部を処理します。
特に、単純な等式文を証明します。
裏では詳細な形式的証明が構築されていますが、`simp`はこの複雑さを隠します。

戦術はいくつかの理由で役立ちます：
1. 多くの証明は最も細かい詳細まで書き出すと複雑で面倒であり、戦術はこれらの面白みのない部分を自動化できます。
2. 戦術を使用して書かれた証明は、時間の経過とともに簡単に保守できるため、柔軟な自動化が定義のわずかな変更を補完できます。
3. 単一の戦術で多くの異なる定理を証明できるため、Leanはユーザーが手動で証明を書く必要がないように裏で戦術を使用できます。たとえば、配列の検索にはインデックスが境界内にあることを証明する必要があり、通常、ユーザーが心配する必要はありません。

裏では、インデックス記法はユーザーの検索操作が安全であることを証明するために戦術を使用します。
この戦術は、特定の算術的同一性を考慮に入れるように設定された `simp`戦術です。


## 接続詞（Connectives）

論理の基本的な構成要素、例えば「かつ」、「または」、「真」、「偽」、および「否定」は _論理的な接続詞_ と呼ばれます。
各接続詞はその真実性の証拠として何を考慮するかを定義します。
例えば、文 "_A_ かつ _B_" を証明するには、_A_ と _B_ の両方を証明する必要があります。
これは "_A_ かつ _B_" の証拠が _A_ の証拠と _B_ の証拠の両方を含むペアであることを意味します。
同様に、"_A_ または _B_" の証拠は _A_ の証拠または _B_ の証拠から成り立っています。

特に、これらの接続詞のほとんどはデータ型のように定義され、それぞれのコンストラクタを持っています。
もし、`A` と `B` が命題であるなら、"`A` かつ `B`"（`{{#example_in Examples/Props.lean AndProp}}` と書かれる）は命題です。
`A ∧ B` の証拠はコンストラクタ `{{#example_in Examples/Props.lean AndIntro}}` から成り立ち、その型は `{{#example_out Examples/Props.lean AndIntro}}` です。
具体的な命題で `A` と `B` を置き換えることで、`{{#example_out Examples/Props.lean AndIntroEx}}` を `{{#example_in Examples/Props.lean AndIntroEx}}` で証明することができます。
もちろん、`simp` もこの証明を見つけるのに十分な力を持っています：

```leantac
{{#example_decl Examples/Props.lean AndIntroExTac}}
```

同様に、"`A` または `B`"（`{{#example_in Examples/Props.lean OrProp}}` と書かれる）は、その下にある命題のうち少なくとも1つが真であることを証明するために、2つのコンストラクタを持っています。
2つのコンストラクタがあります：`{{#example_in Examples/Props.lean OrIntro1}}`（型は `{{#example_out Examples/Props.lean OrIntro1}}`）と `{{#example_in Examples/Props.lean OrIntro2}}`（型は `{{#example_out Examples/Props.lean OrIntro2}}`）です。

含意（もし _A_ ならば _B_）は関数を使用して表されます。
具体的には、_A_ の証拠を _B_ の証拠に変換する関数は、それ自体が _A_ が _B_ を含意する証拠であると言えます。
これは通常の含意の説明と異なり、ここでは `A → B` が `¬A ∨ B` の略記であるのではなく、2つの定式が同等であるということです。

「かつ」の証拠はコンストラクタであるため、パターンマッチングと一緒に使用できます。
例えば、_A_ かつ _B_ が _A_ または _B_ を意味することを証明するには、_A_ と _B_ の証拠から _A_ または _B_ の証拠を取り出し、それを使用して _A_ または _B_ の証拠を生成する関数が必要です：

```lean
{{#example_decl Examples/Props.lean andImpliesOr}}
```

| 接続詞        | Leanの構文 | 証拠          |
|-----------------|-------------|--------------|
| 真（True）     | `True`      | `True.intro : True` |
| 偽（False）    | `False`     | 証拠なし     |
| _A_ かつ _B_   | `A ∧ B`     | `And.intro : A → B → A ∧ B` |
| _A_ または _B_ | `A ∨ B`     | `Or.inl : A → A ∨ B` または `Or.inr : B → A ∨ B` |
| _A_ ならば _B_ | `A → B`     | _A_ の証拠を _B_ の証拠に変換する関数 |
| 否定（not _A_）| `¬A`        | _A_ の証拠を `False` の証拠に変換する関数 |

`simp` 戦術はこれらの接続詞を使用する定理を証明することができます。
例えば以下のような形です：

```leantac
{{#example_decl Examples/Props.lean connectives}}
```


## 引数としての証拠（Evidence as Arguments）

`simp` は特定の数値の等式と不等式を含む命題を証明するのに優れていますが、変数を含む文を証明するのは得意ではありません。
たとえば、`simp` は `4 < 15` を証明できますが、`x < 4` だからといって `x < 15` が真であることを容易に判別できません。
インデックス表記は、配列アクセスが安全であることを証明するために裏で `simp` を使用するため、少し手間がかかることがあります。

インデックス表記をうまく機能させる最も簡単な方法の1つは、データ構造に対するルックアップを実行する関数が安全性の証拠を必要とする引数として受け取ることです。
たとえば、リスト内の3番目のエントリを返す関数は一般的には安全ではありません、なぜならリストにはゼロ、一つ、または二つのエントリが含まれているかもしれないからです：

```lean
{{#example_in Examples/Props.lean thirdErr}}
```

```output error
{{#example_out Examples/Props.lean thirdErr}}
```

しかし、リストが少なくとも3つのエントリを持つことを示す義務は、インデックス操作が安全である証拠から成る引数を追加することで呼び出し元に課せることができます：

```lean
{{#example_decl Examples/Props.lean third}}
```

この例では、`xs.length > 2` は `xs` が2つ以上のエントリを持っているかどうかをチェックする _プログラム_ ではありません。
それは真または偽であるかもしれない命題であり、引数 `ok` はそれが真である証拠である必要があります。

関数が具体的なリストで呼び出されると、その長さは既知です。
これらの場合、`by simp` は証拠を自動的に構築できます：

```leantac
{{#example_in Examples/Props.lean thirdCritters}}
```
```output info
{{#example_out Examples/Props.lean thirdCritters}}
```


## 証拠なしでのインデックス（Indexing Without Evidence）

インデックス操作が境界内であることを証明するのが実用的でない場合、他の代替手段があります。
疑問符を追加することで、結果がインデックスが境界内の場合に `some` になり、それ以外の場合に `none` になる `Option` が生成されます。
たとえば：

```lean
{{#example_decl Examples/Props.lean thirdOption}}

{{#example_in Examples/Props.lean thirdOptionCritters}}
```

```output info
{{#example_out Examples/Props.lean thirdOptionCritters}}
```

```lean
{{#example_in Examples/Props.lean thirdOptionTwo}}
```

```output info
{{#example_out Examples/Props.lean thirdOptionTwo}}
```

また、インデックスが境界外の場合に `Option` を返す代わりに、プログラムをクラッシュさせるバージョンもあります：

```lean
{{#example_in Examples/Props.lean crittersBang}}
```

```output info
{{#example_out Examples/Props.lean crittersBang}}
```

ご注意ください！
`#eval` で実行されるコードはLeanコンパイラのコンテキストで実行されるため、誤ったインデックスを選択するとIDEがクラッシュする可能性があります。


## 遭遇するかもしれないメッセージ（Messages You May Meet）

インデックス操作が安全であることのコンパイル時の証拠を見つけることができない場合に発生するエラーに加えて、危険なインデックスを使用する多相関数は以下のメッセージを生成する可能性があります：

```lean
{{#example_in Examples/Props.lean unsafeThird}}
```

```output error
{{#example_out Examples/Props.lean unsafeThird}}
```

これは、Leanを定理の証明のための論理として使用することとプログラミング言語として使用することの両方ができるように保つ一部の技術的制限に起因しています。
特に、少なくとも1つの値を含む型を持つプログラムだけがクラッシュすることを許可されています。
これは、Leanの命題はその真実性の証拠を分類する種類の型であるためです。
偽の命題にはそのような証拠はありません。
空の型を持つプログラムがクラッシュできる場合、そのクラッシングプログラムは偽の命題の種類の偽の証拠として使用できる可能性があります。

内部的に、Leanは少なくとも1つの値を持つとして知られている型のテーブルを持っています。
このエラーは、ある任意の型 `α` がそのテーブルに必ずしも含まれていないことを示しています。
次の章では、このテーブルに追加する方法や、`unsafeThird` のような関数を正常に書く方法について説明されています。

リストとルックアップに使用される角括弧の間にスペースを追加すると、別のメッセージを発生させることがあります：

```lean
{{#example_in Examples/Props.lean extraSpace}}
```

```output error
{{#example_out Examples/Props.lean extraSpace}}
```

スペースを追加することにより、Leanは式を関数適用として扱い、インデックスを単一の数値を含むリストとして扱おうとします。
このエラーメッセージは、Leanが `woodlandCritters` を関数として扱おこうと試みることによって発生します。


## 演習（Exercises）

* `rfl` を使用して以下の定理を証明してください。
    - `2 + 3 = 5`
    - `15 - 8 = 7`
    - `"Hello, ".append "world" = "Hello, world"`
    - `5 < 18`（`rfl` を使用してこれ証明しようとするとどうなるでしょうか？ また、何故このようなことが起こるのでしょうか？）
* `by simp` を使用して以下の定理を証明してください。
    - `2 + 3 = 5`
    - `15 - 8 = 7`
    - `"Hello, ".append "world" = "Hello, world"`
    - `5 < 18`
* リスト内の5番目のエントリを検索する関数を書いてください。この検索が安全であることの証拠を関数への引数として渡してください。
